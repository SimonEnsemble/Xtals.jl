module Bonds_test

using Xtals, Graphs, Test, MetaGraphs, LinearAlgebra

irmof1 = Crystal("IRMOF-1.cif")
cof102 = Crystal("cof-102.cif")

@testset "bond arithmetic" begin
    xtal = deepcopy(irmof1)
    xtal1 = deepcopy(xtal)
    infer_bonds!(xtal, true)
    xtal2 = xtal[1:10]
    xtal3 = +(xtal, xtal2, check_overlap=false)
    xtal4 = +(xtal2, xtal, check_overlap=false)

    # check "conservation of matter"
    @test nv(xtal3.bonds) == nv(xtal.bonds) + nv(xtal2.bonds)

    # check "conservation of energy"
    @test ne(xtal3.bonds) == ne(xtal.bonds) + ne(xtal2.bonds)

    # check commutivity
    @test xtal3.atoms.n == xtal4.atoms.n

    @test ne(xtal3.bonds) == ne(xtal4.bonds)
    
    @test nv(xtal3.bonds) == nv(xtal4.bonds)

    # check adding when 1 or both have no bonds
    xtal5 = +(xtal1, xtal2, check_overlap=false)
    xtal6 = +(xtal2, xtal1, check_overlap=false)
    xtal7 = +(xtal1, xtal1, check_overlap=false)

    @test ne(xtal5.bonds) == ne(xtal2.bonds)
    
    @test ne(xtal6.bonds) == ne(xtal2.bonds)
    
    @test ne(xtal7.bonds) == 0
end

include("bond_vectors.jl")

@testset "bond sanity check" begin
    box = unit_cube()
    texas_carbon = read_xyz(joinpath(rc[:paths][:crystals], "texas_carbon.xyz"))
    xtal = Crystal("CH5", box, Atoms(texas_carbon.n, texas_carbon.species, Frac(texas_carbon.coords, box)), Charges{Frac}(0))
    
    @test !bond_sanity_check(xtal)[1]
    
    infer_bonds!(xtal, false)
    
    @test !bond_sanity_check(xtal)[1]
    
    trihydrogen = read_xyz(joinpath(rc[:paths][:crystals], "trihydrogen.xyz"))
    xtal = Crystal("H3", box, Atoms(trihydrogen.n, trihydrogen.species, Frac(trihydrogen.coords, box)), Charges{Frac}(0))
    infer_bonds!(xtal, false)
    
    @test !bond_sanity_check(xtal)[1]
end


@testset "NiPyC2 Tests" begin
    # NiPyC2 bonding
    c = Crystal("NiPyC2_relax.cif")
    strip_numbers_from_atom_labels!(c)
    c = replicate(c, (4, 4, 4))
    bonding_rules = [BondingRule(:H, :*, 1.2),
                     BondingRule(:Ni, :O, 2.5),
                     BondingRule(:Ni, :N, 2.5),
                     BondingRule(:*, :*, 1.9)]
    infer_bonds!(c, true, bonding_rules=bonding_rules)
    c1 = deepcopy(c)
    conn_comps = connected_components(c.bonds)

    @test length(conn_comps) == 2 # interpenetrated

    c_red = getindex(c, conn_comps[1])
    c_blue = getindex(c, conn_comps[2])

    @test ne(c_red.bonds) + ne(c_blue.bonds) == ne(c.bonds)
    
    @test length(conn_comps) == 2 # interpenetrated
end


@testset "BACMOH Tests" begin
    xtal = Crystal("BACMOH_clean.cif")
    strip_numbers_from_atom_labels!(xtal)
    infer_bonds!(xtal, true)

    @test bond_sanity_check(xtal)
    
    @test xtal.atoms.species[1] == :Cu
    
    @test xtal.atoms.species[neighbors(xtal.bonds, 1)] == [:O, :N, :N, :O]
end


@testset ".mol/.cif bonds vs. inferred" begin
    mol_atoms, mol_bonds = read_mol("data/example.mol")
    box = unit_cube()
    xtal = Crystal("example.mol", box, Frac(mol_atoms, box), Charges{Frac}(0))
    infer_bonds!(xtal, false)
    
    @test mol_bonds == xtal.bonds
    
    mol_atoms, mol_bonds = read_mol("data/cof-102.mol")
    xtal = deepcopy(cof102)
    infer_bonds!(xtal, false) # source mol file has no periodic bonds
    
    @test mol_bonds == xtal.bonds
end


@testset "metadata" begin
    xtal = deepcopy(cof102)
    infer_bonds!(xtal, true)
    bonds = deepcopy(xtal.bonds)
    e = collect(edges(xtal.bonds))[1]
    set_prop!(xtal.bonds, src(e), dst(e), :distance, missing)
    Xtals.calc_missing_bond_distances!(xtal)

    @test xtal.bonds == bonds
    
    xtal2 = deepcopy(cof102)
    infer_bonds!(xtal2, false)
    drop_cross_pb_bonds!(xtal)
    
    @test xtal.bonds == xtal2.bonds
    
    write_mol2(xtal, filename=tempname())
end


@testset "bonding rules" begin
    bonding_rules_path = tempname()
    write_bonding_rules(bonding_rules_path)
    
    @test isfile(bonding_rules_path)
    
    bonding_rules = read_bonding_rules(bonding_rules_path)
    n = 4656 # the number generated by default. subject to change.
    
    @test length(bonding_rules) == n
    
    add_bonding_rules([BondingRule(:foo, :bar, 5.)])
    
    @test length(rc[:bonding_rules]) == (n + 1)
    
    println([r for r ∈ bonding_rules if :C == r.species_j][1])
    
    @test true

    rc[:bonding_rules] = [BondingRule(:foo, :bar, 0.0)]
    xtal = deepcopy(cof102)
    
    @test isnan(Xtals.is_bonded(xtal, 1, 2, rc[:bonding_rules])[2])
    
    rc[:bonding_rules] = bondingrules()

    @test true
end


@testset "etc" begin
    temp_vtk_path = tempname()
    xtal = Crystal("SBMOF-1.cif")
    write_bond_information(xtal, temp_vtk_path, center_at_origin=true)

    @test isfile(temp_vtk_path * ".vtk")

    xtal = deepcopy(irmof1)
    infer_bonds!(xtal, true)
    write_xyz(xtal, tempname())
    all_bonds_temppath = tempname()
    no_pb_temppath = tempname()
    write_bond_information(xtal, all_bonds_temppath)
    write_bond_information(xtal, no_pb_temppath, bond_filter=:cross_boundary=>p->!p)

    @test all(isfile.([all_bonds_temppath, no_pb_temppath] .* ".vtk"))
end


@testset "bonds from xyz" begin
    xtal = deepcopy(irmof1)
    infer_bonds!(xtal, false)
    bonds = infer_bonds(Cart(xtal.atoms, xtal.box))

    @test bonds == xtal.bonds
end


@testset "infer_bonds kwarg" begin
    xtal1 = Crystal("IRMOF-1.cif", infer_bonds=true, periodic_boundaries=true)
    xtal2 = Crystal("IRMOF-1.cif", infer_bonds=true, periodic_boundaries=false)

    @test xtal1.bonds ≠ xtal2.bonds

    @test_throws ErrorException Crystal("IRMOF-1.cif", infer_bonds=true)
end

end
