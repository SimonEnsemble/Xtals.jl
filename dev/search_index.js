var documenterSearchIndex = {"docs":
[{"location":"matter/","page":"matter","title":"matter","text":"DocTestSetup = quote\n  using Xtals\nend","category":"page"},{"location":"matter/#Matter-and-Coordinates","page":"matter","title":"Matter and Coordinates","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"Atoms and Charges are the building blocks of Crystals and molecules in Xtals.jl.  Each have coordinates in both Cartesian and Fractional space (associated with unit cell information, i.e., a Box).","category":"page"},{"location":"matter/#Coordinates","page":"matter","title":"Coordinates","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"We store coordinates as an abstract Coords type that has two subtypes: Cart and Frac for Cartesian and Fractional, respectively.  See the Wikipedia page on fractional coordinates, which are defined in the context of a periodic system, e.g. within a crystal.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"Construct coordinates of n particles by passing a n by 3 array:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"# construct cartesian coordinates of a particle\ncoord = Cart([1.0, 2.0, 5.0])\ncoord.x\n# output\n3×1 Matrix{Float64}:\n 1.0\n 2.0\n 5.0","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"# construct fractional coordinates of a particle\ncoord = Frac([0.1, 0.2, 0.5])\ncoord.xf\n# output\n3×1 Matrix{Float64}:\n 0.1\n 0.2\n 0.5","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"The coordinates of multiple particles are stored column-wise:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"# five particles at uniform random coordinates\ncoords = Cart([\n  0.0 1.0 0.0 0.0 1.0;\n  0.0 0.0 1.0 0.0 1.0;\n  0.0 0.0 0.0 1.0 1.0\n])","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"Many Array operations work on Coords, such as:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords[2]                      # coordinate of 2nd particle\ncoords[2:3]                    # (slicing by index) coords of particles 2 and 3\ncoords[[1, 2, 5]]              # (slicing by index) coords of particles 1, 2, and 5\ncoords[rand(Bool, 5)]          # (boolean slicing) coords, selected at random\nlength(coords)                 # number of particles, (5)","category":"page"},{"location":"matter/#Manipulating-coordinates","page":"matter","title":"Manipulating coordinates","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"Coords are immutable:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords.x = rand(3, 5)\n# output\nERROR: setfield!: immutable struct of type Cart cannot be changed","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"But we can manipulate the values of Array{Float64, 2} where coordinates (through coords.x or coords.xf) are stored:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords.x[2, 3] = 100.0         # successful!\ncoords.x[:] = rand(3, 5)       # successful! (achieves the above, but need the [:] to say \"overwrite all of the elements\"","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"Fractional coordinates can be wrapped to be inside the unit cell box:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"coords = Frac([1.2, -0.3, 0.9])\nwrap!(coords)\ncoords.xf\n# output\n3×1 Matrix{Float64}:\n 0.19999999999999996\n 0.7\n 0.9","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"We can translate coordinates by a vector dx:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"dx = Cart([1.0, 2.0, 3.0])\ncoords = Cart([1.0, 0.0, 0.0])  \ntranslate_by!(coords, dx)\ncoords.x\n# output\n3×1 Matrix{Float64}:\n 2.0\n 2.0\n 3.0","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"If dx::Frac and coords::Cart, translate_by! requires a Box to convert between Fractional and Cartesian, as the last argument:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"dx = Frac([0.1, 0.2, 0.3])\nbox = unit_cube()\ncoords = Cart([1.0, 0.0, 0.0])\ntranslate_by!(coords, dx, box)\ncoords.x\n# output\n3×1 Matrix{Float64}:\n 1.1\n 0.20000000000000004\n 0.3","category":"page"},{"location":"matter/#Atoms","page":"matter","title":"Atoms","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"An atom is specified by its coordinates and atomic species. We can construct a set of Atoms (perhaps comprising a molecule or crystal) as follows:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"species = [:O, :H, :H]            # atomic species are represnted with Symbols\ncoords = Cart([0.0 0.757 -0.757;  # coordinates of each\n               0.0 0.586  0.586;\n               0.0 0.0    0.0   ]\n             )\natoms = Atoms(species, coords)    # 3 atoms comprising water\natoms.n                           # number of atoms, 3\natoms.coords                      # coordinates; atoms.coords.x gives the array of coords\natoms.species                     # array of species\natoms::Atoms{Cart}                # successful type assertion, as opposed to atoms::Atoms{Frac}","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"The last line illustrates the two subtypes of Atoms, depending on whether the Coords are stored as Fractional or Cartesian.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"We can slice Atoms, such as:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"atoms[1]                         # 1st atom\natoms[2:3]                       # 2nd and 3rd atom","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"And combine them:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"atoms_combined = atoms[1] + atoms[2:3]   # combine atoms 1, 2, and 3\nisapprox(atoms, atoms_combined)\n# output\ntrue","category":"page"},{"location":"matter/#Charges","page":"matter","title":"Charges","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"Point Charges work analogously to Atoms, except instead of species, the values of the point charges are stored in an array q.","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"q = [-1.0, 0.5, 0.5]              # values of point charges, units: electrons\ncoords = Cart([0.0 0.757 -0.757;  # coordinates of the point charges\n               0.0 0.586  0.586;\n               0.0 0.0    0.0   ]\n             )\ncharges = Charges(q, coords)      # 3 point charges\ncharges.n                         # number of charges, 3\ncharges.coords                    # retreive coords\ncharges.q                         # retreive q\ncharges::Charges{Cart}            # successful type assertion, as opposed to charges::Charges{Frac}","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"We can determine if the set of point charges comprise a charge-neutral system by:","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"net_charge(charges)\n# output\n0.0","category":"page"},{"location":"matter/","page":"matter","title":"matter","text":"neutral(charges)\n# output\ntrue","category":"page"},{"location":"matter/#Detailed-Docs","page":"matter","title":"Detailed Docs","text":"","category":"section"},{"location":"matter/","page":"matter","title":"matter","text":"    Coords\n    Frac\n    Cart\n    Atoms\n    Charges\n    net_charge\n    neutral\n    translate_by!","category":"page"},{"location":"matter/#Xtals.Coords","page":"matter","title":"Xtals.Coords","text":"abstract type for coordinates.\n\n\n\n\n\n","category":"type"},{"location":"matter/#Xtals.Frac","page":"matter","title":"Xtals.Frac","text":"fractional coordinates, a subtype of Coords.\n\nconstruct by passing an Array{Float64, 2} whose columns are the coordinates.\n\ngenerally, fractional coordinates should be in [0, 1] and are implicitly associated with a Box to represent a periodic coordinate system.\n\ne.g.\n\nf_coords = Frac(rand(3, 2))  # 2 particles\nf_coords.xf                  # retreive fractional coords\n\n\n\n\n\n","category":"type"},{"location":"matter/#Xtals.Cart","page":"matter","title":"Xtals.Cart","text":"cartesian coordinates, a subtype of Coords.\n\nconstruct by passing an Array{Float64, 2} whose columns are the coordinates.\n\ne.g.\n\nc_coords = Cart(rand(3, 2))  # 2 particles\nc_coords.x                   # retreive cartesian coords\n\n\n\n\n\n","category":"type"},{"location":"matter/#Xtals.Atoms","page":"matter","title":"Xtals.Atoms","text":"used to represent a set of atoms in space (their atomic species and coordinates).\n\nstruct Atoms{T<:Coords} # enforce that the type specified is `Coords`\n    n::Int # how many atoms?\n    species::Array{Symbol, 1} # list of species\n    coords::T # coordinates\nend\n\nhere, T is Frac or Cart.\n\nhelper constructor (infers n):\n\nspecies = [:H, :H]\ncoords = Cart(rand(3, 2))\natoms = Atoms(species, coords)\n\n\n\n\n\n","category":"type"},{"location":"matter/#Xtals.Charges","page":"matter","title":"Xtals.Charges","text":"used to represent a set of partial point charges in space (their charges and coordinates).\n\nstruct Charges{T<:Coords} # enforce that the type specified is `Coords`\n    n::Int\n    q::Array{Float64, 1}\n    coords::T\nend\n\nhere, T is Frac or Cart.\n\nhelper constructor (infers n):\n\nq = [0.1, -0.1]\ncoords = Cart(rand(3, 2))\ncharges = Charges(q, coords)\n\n\n\n\n\n","category":"type"},{"location":"matter/#Xtals.net_charge","page":"matter","title":"Xtals.net_charge","text":"nc = net_charge(charges)\nnc = net_charge(crystal)\nnc = net_charge(molecule)\n\nfind the sum of charges in charges::Charges or charges in crystal::Crystal or molecule::Molecule. (if there are no charges, the net charge is zero.)\n\n\n\n\n\n","category":"function"},{"location":"matter/#Xtals.neutral","page":"matter","title":"Xtals.neutral","text":"neutral(charges, tol) # true or false. default tol = 1e-5\nneutral(crystal, tol) # true or false. default tol = 1e-5\n\ndetermine if a set of charges::Charges (charges.q) sum to an absolute value less than tol::Float64. if crystal::Crystal is passed, the function looks at the crystal.charges. i.e. determine the absolute value of the net charge is less than tol.\n\n\n\n\n\n","category":"function"},{"location":"matter/#Xtals.translate_by!","page":"matter","title":"Xtals.translate_by!","text":"translate_by!(coords, dx)\ntranslate_by!(coords, dx, box)\ntranslate_by!(molecule, dx)\ntranslate_by!(molecule, dx, box)\n\ntranslate coords by the vector dx. that is, add the vector dx.\n\nthis works for any combination of Frac and Cart coords.\n\nmodifies coordinates in place.\n\nbox is needed when mixing Frac and Cart coords.\n\nnote that periodic boundary conditions are not subsequently applied here.\n\nif applied to a molecule::Molecule, the coords of atoms, charges, and center of mass are all translated.\n\n\n\n\n\n","category":"function"},{"location":"globals/#Global-Variables","page":"globals","title":"Global Variables","text":"","category":"section"},{"location":"globals/","page":"globals","title":"globals","text":"In Xtals.jl, global variables are stored in a dictionary called rc.   The entries in rc are used for holding various important pieces of information:","category":"page"},{"location":"globals/","page":"globals","title":"globals","text":"rc[:atomic_masses] : a dictionary which maps atomic species to their masses in AMU\nrc[:cpk_colors] : a dictionary which maps atomic species to their CPK colors\nrc[:bonding_rules] : an array which lists the maximum bonding distances between each pair of atom types in Å\nrc[:covalent_radii] : a dictionary which maps atomic species to their covalent radii in Å\nrc[:paths] : a dictionary of paths to directories to search for input data","category":"page"},{"location":"globals/#Paths","page":"globals","title":"Paths","text":"","category":"section"},{"location":"globals/","page":"globals","title":"globals","text":"The rc[:paths] dictionary holds the following:","category":"page"},{"location":"globals/","page":"globals","title":"globals","text":"rc[:paths][:crystals] : the path to find crystallographic files (.cif, .cssr) to read in\nrc[:paths][:data] : not directly used by Xtals.jl, but important for other packages which use Xtals, e.g. PorousMaterials.jl","category":"page"},{"location":"globals/","page":"globals","title":"globals","text":"When Xtals is first loaded, the paths are set based on the present working directory.   Xtals expects to find a folder named data in the working directory, and assumes that crystallographic data will be present in data/crystals.   To change the location of the crystal inputs, either set rc[:paths][:crystals] directly, or use set_paths:","category":"page"},{"location":"globals/","page":"globals","title":"globals","text":"rc[:paths][:crystals] = \"other_crystals\" # crystals are now loaded from \"other_crystals\"\nset_paths(\"other_data\") # crystals are now loaded from \"other_data/crystals\"","category":"page"},{"location":"globals/#Detailed-Docs","page":"globals","title":"Detailed Docs","text":"","category":"section"},{"location":"globals/","page":"globals","title":"globals","text":"set_paths","category":"page"},{"location":"globals/#Xtals.set_paths","page":"globals","title":"Xtals.set_paths","text":"`set_paths(\"path_to_data\", print_paths=true)`\n\nSets all paths in rc[:paths] relative to path_to_data.  Paths follow the standard format of  rc[:paths][:foo] = \"path_to_data/foo\", except for rc[:paths][:data] which is \"path_to_data\". Warnings are issued if any chosen paths are not valid folders.\n\nArguments\n\npath_to_data::String : an absolute or relative path to use as the root of the data folder tree. Defaults to present working directory.\nprint_paths::Bool : Optional.  If true, prints contents of rc[:paths] to console.  Defaults to false.\nno_warn::Bool : Optional.  Set true to suppress invalid path warnings.  Default to false.\n\n\n\n\n\n","category":"function"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"DocTestSetup = quote\n  using Xtals\nend","category":"page"},{"location":"distance/#Distances","page":"computing distances","title":"Distances","text":"","category":"section"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"The distance between two Atoms in a Crystal is central to many operations within Xtals.jl.   The distance function calculates the Cartesian displacement between the Coords (Cart or Frac) of two points, i and j, within a given Box, in units of Å.","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"xtal = Crystal(\"IRMOF-1.cif\")\ndistance(xtal.atoms.coords, xtal.box, 1, 2, false)\n# output\n18.538930020700434","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"The apply_pbc argument allows for calculation of distances across the periodic boundaries of the Box.","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"distance(xtal.atoms.coords, xtal.box, 1, 2, true)\n# output\n15.096469110488975","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"distance also works on Atoms and Charges.","category":"page"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"distance(xtal.atoms, xtal.box, 3, 5, true)\n# output\n16.90555095103936","category":"page"},{"location":"distance/#Detailed-Docs","page":"computing distances","title":"Detailed Docs","text":"","category":"section"},{"location":"distance/","page":"computing distances","title":"computing distances","text":"distance","category":"page"},{"location":"distance/#Xtals.distance","page":"computing distances","title":"Xtals.distance","text":"r = distance(coords, box, i, j, apply_pbc)\nr = distance(atoms, box, i, j, apply_pbc) # atoms i and j\nr = distance(charges, box, i, j, apply_pbc) # charges i and j\nr = distance(atoms, i, j) # no PBCs, coords must be in Cartesian coords\nr = distance(coords, i, j) # no PBCs, coords must be in Cartesian coords\n\ncalculate the (Cartesian) distance between particles i and j.\n\napply periodic boundary conditions if and only if apply_pbc is true.\n\narguments\n\ncoords::Coords: the coordinates (Frac>:Coords or Cart>:Coords)\natoms::Atoms: atoms\ncharges::charges: atoms\nbox::Box: unit cell information\ni::Int: index of the first particle\nj::Int: Index of the second particle\napply_pbc::Bool: true if we wish to apply periodic boundary conditions, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"bonds/","page":"bonding","title":"bonding","text":"DocTestSetup = quote\n  using Xtals\nend","category":"page"},{"location":"bonds/#Chemical-Bonding","page":"bonding","title":"Chemical Bonding","text":"","category":"section"},{"location":"bonds/","page":"bonding","title":"bonding","text":"Chemical bonding interactions are represented in the bonds attribute of a Crystal as a graph. The nodes of the graph correspond to the Crystal's Atoms, and the edges of the graph correspond to the bonds (xtal.bonds).","category":"page"},{"location":"bonds/#Bonding-Rules","page":"bonding","title":"Bonding Rules","text":"","category":"section"},{"location":"bonds/","page":"bonding","title":"bonding","text":"Xtals uses an array of BondingRule structs stored in rc for deciding if two Atoms are an appropriate distance to be chemically bonded.   The default rules are based on the Cordero covalent radii, modified based on the work of Thomas Manz.   Each BondingRule is composed of two chemical species symbols and a floating point value, the maximum distance for inferring a bond between the indicated species.","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"BondingRule(:C, :C, 1.77)","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"The global bonding rules may be augmented with add_bonding_rules or written to/read from disk with write_bonding_rules and read_bonding_rules.   The default rules are determined from rc[:covalent_radii] at module load, but are not recalculated upon changes to the covalent radii.   If rc[:covalent_radii] is altered and new bonding rules should be calculated, the user must do rc[:bonding_rules] = bondingrules().","category":"page"},{"location":"bonds/#Adding-Bonds-to-Crystals","page":"bonding","title":"Adding Bonds to Crystals","text":"","category":"section"},{"location":"bonds/","page":"bonding","title":"bonding","text":"By default, bonding information is not added to a Crystal.  Bonds may be inferred at the time of loading structure data by using the infer_bonds keyword argument.   See Crystal for more details.","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"xtal = Crystal(\"SBMOF-1.cif\", infer_bonds=true, periodic_boundaries=true)\nxtal.bonds\n# output\n{120, 144} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0)","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"The first number is the number of nodes, and the second is the number of edges.   The :weight attribute is not used, and can be ignored.","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"remove_bonds! clears the bonding information from a Crystal:","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"remove_bonds!(xtal)\nxtal.bonds\n# output\n{120, 0} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0)","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"Use infer_bonds! to infer plausible bonds using the global bonding rules (or another specified set of rules) in already-loaded Crystals:","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"infer_bonds!(xtal, true)\nxtal.bonds\n# output\n{120, 144} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0)","category":"page"},{"location":"bonds/#Bonds-from-Input-File","page":"bonding","title":"Bonds from Input File","text":"","category":"section"},{"location":"bonds/","page":"bonding","title":"bonding","text":"Some chemical information formats, like .cif and .mol, can store not only the cartesian coordinates of atoms, but also the graph of bonds between atoms in molecules and crystals.   The read_bonds_from_file keyword argument for Crystal enables loading these bonds when reading the data.   read_mol also returns bond information.","category":"page"},{"location":"bonds/#Bonds-for-Atoms","page":"bonding","title":"Bonds for Atoms","text":"","category":"section"},{"location":"bonds/","page":"bonding","title":"bonding","text":"In the case that atomic coordinates are loaded from XYZ format, there will be no unit cell information.   To infer bonds between atoms in this case, use the infer_bonds function:","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"atoms = Cart(xtal.atoms, xtal.box) # get atoms in Cartesian coords\nbonds = infer_bonds(atoms) # infer bonding graph\n# output\n{120, 110} undirected Int64 metagraph with Float64 weights defined by :weight (default weight 1.0)","category":"page"},{"location":"bonds/#Bond-Distances,-Vectors,-and-Angles","page":"bonding","title":"Bond Distances, Vectors, and Angles","text":"","category":"section"},{"location":"bonds/","page":"bonding","title":"bonding","text":"Bonds may be labeled with several additional pieces of information.   The first is the center-to-center distance between the bonded atoms, accessible via bond_distance:","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"bond_distance(xtal, 1, 5)\n# output\n1.5233240952030063","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"The bond distance is automatically added by infer_bonds!.  Applying calculate_bond_vectors! (or passing calculate_vectors=true to infer_bonds!) labels each edge in the bonding graph with a vector, accessible via get_bond_vector:","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"calculate_bond_vectors!(xtal)\nget_bond_vector(xtal, 1, 5)\n# output\n3-element Vector{Float64}:\n -1.2460713575602618\n -0.26441824999999985\n  0.8354073616870523","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"While the bond graph itself is undirected, the vectors returned by get_bond_vector are directed, so reversing the order of the node indices will flip the vector:","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"get_bond_vector(xtal, 5, 1)\n# output\n3-element Vector{Float64}:\n  1.2460713575602618\n  0.26441824999999985\n -0.8354073616870523","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"Bond angles are calculated via the dot product: θ = arccos(u⃗•v⃗ / (‖u⃗‖*‖v⃗‖)) To get the angle (in radians) between two bonds, use bond_angle:","category":"page"},{"location":"bonds/","page":"bonding","title":"bonding","text":"bond_angle(xtal, 1, 5, 9)\n# output\n2.089762039489374","category":"page"},{"location":"bonds/#Detailed-Docs","page":"bonding","title":"Detailed Docs","text":"","category":"section"},{"location":"bonds/","page":"bonding","title":"bonding","text":"BondingRule\nadd_bonding_rules\nread_bonding_rules\nwrite_bonding_rules\ninfer_bonds!\ninfer_bonds\nremove_bonds!\nwrite_bond_information\nbond_distance\ncalculate_bond_vectors!\nclear_vectors!\nget_bond_vector\nbond_angle","category":"page"},{"location":"bonds/#Xtals.BondingRule","page":"bonding","title":"Xtals.BondingRule","text":"bonding_rule = BondingRule(:Ca, :O, 2.0)\nbonding_rules = [BondingRule(:H, :*, 1.2),\n                 BondingRule(:*, :*, 1.9)]\n\nA rule for determining if two atoms within a crystal are bonded.\n\nAttributes\n\nspecies_i::Symbol: One of the atoms types for this bond rule\nspecies_j::Symbol: The other atom type for this bond rule\nmax_dist: The maximum distance between the atoms for bonding to occur\n\n\n\n\n\n","category":"type"},{"location":"bonds/#Xtals.add_bonding_rules","page":"bonding","title":"Xtals.add_bonding_rules","text":"add_bonding_rules(bonding_rules)\n\nAdds bonding_rules to the beginning of the global bonding rules list\n\nArguments\n\nbonding_rules::Array{BondingRule} : the array of bonding rules to add\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.read_bonding_rules","page":"bonding","title":"Xtals.read_bonding_rules","text":"read_bonding_rules(\"file.csv\")\n\nReads a CSV file of bonding rules and returns a BondingRule array.\n\nArguments\n\nfilename::String : name of file in data directory containing bonding rules\n\nReturns\n\nrules::Array{BondingRule} : the bonding rules read from file\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.write_bonding_rules","page":"bonding","title":"Xtals.write_bonding_rules","text":"write_bonding_rules(\"file.csv\")\n\nWrites bonding rules to a CSV file that can be loaded with read_bonding_rules\n\nArguments\n\nfilename::String : The name of the output file\nbonding_rules::Array{BondingRule} : (Optional) The rules to write to file. If not specified, the global rules are written.\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.infer_bonds!","page":"bonding","title":"Xtals.infer_bonds!","text":"infer_bonds!(crystal, include_bonds_across_periodic_boundaries; bonding_rules=rc[:bonding_rules])\n\nPopulate the bonds in the crystal object based on the bonding rules. If a pair doesn't have a suitable rule then they will not be considered bonded.\n\n:* is considered a wildcard and can be substituted for any species. It is a good idea to include a bonding rule between two :* to allow any atoms to bond as long as they are close enough.\n\nThe bonding rules are hierarchical, i.e. the first bonding rule takes precedence over the latter ones.\n\nArguments\n\ncrystal::Crystal: The crystal that bonds will be added to.\ninclude_bonds_across_periodic_boundaries::Bool: Whether to check across the periodic boundary when calculating bonds.\nbonding_rules::Array{BondingRule, 1}: The array of bonding rules that will be used to fill the bonding information. They are applied in the order that they appear. rc[:bonding_rules] will be used if none provided.\ncalculate_vectors::Bool: Optional. Set true to annotate all edges in the bonds graph with vector information.\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.infer_bonds","page":"bonding","title":"Xtals.infer_bonds","text":"bonds = infer_bonds(atoms; bonding_rules=rc[:bonding_rules])\n\nReturns a MetaGraph encoding the chemical bonds between atoms.\n\nArguments\n\natoms::Atoms{Cart}: the atoms to bond\nbonding_rules::Vector{BondingRule}: the bonding rules to use\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.remove_bonds!","page":"bonding","title":"Xtals.remove_bonds!","text":"remove_bonds!(crystal)\n\nRemove all bonds from a crystal structure, crystal::Crystal.\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.write_bond_information","page":"bonding","title":"Xtals.write_bond_information","text":"write_bond_information(crystal, filename)\nwrite_bond_information(crystal, center_at_origin=false)\nwrite_bond_information(xtal, filename, :cross_boundary => p -> p, \"bonds.vtk\") # cross-boundary bonds only\nwrite_bond_information(xtal, filename, :distance => d -> d < 1.0, \"bonds.vtk\") # distance less than 1.0\n\nWrites the bond information from a crystal to the selected filename.\n\nArguments\n\ncrystal::Crystal: The crystal to have its bonds written to a vtk file\nfilename::String: The filename the bond information will be saved to. If left out, will default to crystal name.\ncenter_at_origin::Bool: (optional) center the coordinates at the origin of the crystal\nbond_filter::Pair{Symbol, Function}: (optional) a key-value pair of an edge attribute and a predicate function. Bonds with attributes that cause the predicate to return false are excluded from writing.\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.bond_distance","page":"bonding","title":"Xtals.bond_distance","text":"`bond_distance(xtal, i, j)`\n`bond_distance(xtal.bonds, i, j)`\n\nGives the distance between two bonded atoms in a crystal or two nodes in a bonding graph. Returns NaN if the atoms (nodes) are not bonded (connected).\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.calculate_bond_vectors!","page":"bonding","title":"Xtals.calculate_bond_vectors!","text":"`calculate_bond_vectors!(xtal)`\n\nAdds a property to the edges of a crystal's bonding graph giving the vector between source and destination nodes in Cartesian space.\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.clear_vectors!","page":"bonding","title":"Xtals.clear_vectors!","text":"`clear_vectors!(xtal)`\n`clear_vectors!(xtal.bonds)`\n\nRemoves edge vector attributes from crystal bonding graph.\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.get_bond_vector","page":"bonding","title":"Xtals.get_bond_vector","text":"`get_bond_vector(bonds, i, j)`\n\nReturns the vector between connected nodes i and j of the bonds graph.\n\n\n\n\n\n","category":"function"},{"location":"bonds/#Xtals.bond_angle","page":"bonding","title":"Xtals.bond_angle","text":"`bond_angle(xtal.bonds, 2, 1, 3)`\n`bond_angle(xtal, 8, 121, 42)`\n\nReturns the bond angle between three nodes of a bonding graph (or three atoms in a crystal), if the edges (bonds) exist. Otherwise, returns NaN\n\n\n\n\n\n","category":"function"},{"location":"box/","page":"boxes","title":"boxes","text":"DocTestSetup = quote\n  using Xtals\nend","category":"page"},{"location":"box/#The-Spatial-Box","page":"boxes","title":"The Spatial Box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"Within Xtals.jl, the 3D space in which all Coords are located is the Box.   Each Crystal has its own Box, equivalent to the unit cell of a material, containing as attributes the unit cell edge lengths (a b c), crystallographic dihedral angles (α β γ), volume, conversion factors for translating between Fractional and Cartesian coordinates, and the reciprocal (Fourier transform) vectors for the Bravais lattice.","category":"page"},{"location":"box/#Defining-a-Box","page":"boxes","title":"Defining a Box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"A Box is most conveniently constructed from its basic spatial data (a b c α β γ).   For example, given the unit cell of Co-MOF-74, we can define its Box:","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"a = 26.13173 # Å\nb = 26.13173\nc = 6.722028\nα = π/2 # radians\nβ = π/2\nγ = 2*π/3\nbox = Box(a, b, c, α, β, γ)","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"A Box may also be defined by providing only the Fractional-to-Cartesian conversion matrix:","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"box = Box([26.1317 -13.0659 0; 0 22.6307 0; 0 0 6.72203])","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"To quickly get a simple unit-cubic Box, use the unit_cube function.","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"@info unit_cube()\n#┌ Info: Bravais unit cell of a crystal.\n#│       Unit cell angles α = 90.000000 deg. β = 90.000000 deg. γ = 90.000000 deg.\n#│       Unit cell dimensions a = 1.000000 Å. b = 1.000000 Å, c = 1.000000 Å\n#└       Volume of unit cell: 1.000000 Å³","category":"page"},{"location":"box/#Transforming-Coordinates","page":"boxes","title":"Transforming Coordinates","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"Conversions are provided for switching between Fractional and Cartesian Coords using the Box (works for Atoms and Charges, too).","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"xtal = Crystal(\"Co-MOF-74.cif\")\nCart(xtal.atoms.coords, xtal.box)\n#Cart([-5.496156112249995 7.181391379950001 … 15.131970232450003 2.4686645331000063;\n# 22.270234304380295 2.8331425940892103 … 0.7607701110682343 22.13256395706254;\n# 1.231811631 0.32198514120000005 … 6.2082409932000004 2.2119953472])","category":"page"},{"location":"box/#Replicating-a-Box","page":"boxes","title":"Replicating a Box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"For simulations in larger volumes than a single crystallograhic unit cell, the Box may be replicated along each or any of the three crystallographic axes.   See replicate.","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"replicated_box = replicate(box, (2,2,2))","category":"page"},{"location":"box/#Exporting-a-Box","page":"boxes","title":"Exporting a Box","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"For visualization of the unit cell boundaries, the Box may be written out to a .vtk file for use in Visit.","category":"page"},{"location":"box/","page":"boxes","title":"boxes","text":"write_vtk(box, \"box.vtk\")","category":"page"},{"location":"box/#Detailed-Docs","page":"boxes","title":"Detailed Docs","text":"","category":"section"},{"location":"box/","page":"boxes","title":"boxes","text":"    Box\n    unit_cube\n    write_vtk","category":"page"},{"location":"box/#Xtals.Box","page":"boxes","title":"Xtals.Box","text":"box = Box(a, b, c, α, β, γ, volume, f_to_c, c_to_f, reciprocal_lattice)\nbox = Box(a, b, c, α, β, γ)\nbox = Box(a, b, c) # α=β=γ=π/2 assumed.\nbox = Box(f_to_c)\n\nData structure to describe a unit cell box (Bravais lattice) and convert between fractional and Cartesian coordinates.\n\nAttributes\n\na,b,c::Float64: unit cell dimensions (units: Angstroms)\nα,β,γ::Float64: unit cell angles (units: radians)\nΩ::Float64: volume of the unit cell (units: cubic Angtroms)\nf_to_c::Array{Float64,2}: the 3x3 transformation matrix used to map fractional\n\ncoordinates to cartesian coordinates. The columns of this matrix define the unit cell axes. Columns are the vectors defining the unit cell box. units: Angstrom\n\nc_to_f::Array{Float64,2}: the 3x3 transformation matrix used to map Cartesian\n\ncoordinates to fractional coordinates. units: inverse Angstrom\n\nreciprocal_lattice::Array{Float64, 2}: the rows are the reciprocal lattice vectors.\n\nThis choice was made (instead of columns) for speed of Ewald Sums.\n\n\n\n\n\n","category":"type"},{"location":"box/#Xtals.unit_cube","page":"boxes","title":"Xtals.unit_cube","text":"uc = unit_cube()\n\nThis function generates a unit cube, each side is 1.0 Angstrom long, and all the corners are right angles.\n\n\n\n\n\n","category":"function"},{"location":"box/#Xtals.write_vtk","page":"boxes","title":"Xtals.write_vtk","text":"write_vtk(box, filename; verbose=true, center_at_origin=false)\nwrite_vtk(framework)\n\nWrite a Box to a .vtk file for visualizing e.g. the unit cell boundary of a crystal. If a Framework is passed, the Box of that framework is written to a file that is the same as the crystal structure filename but with a .vtk extension.\n\nAppends \".vtk\" extension to filename automatically if not passed.\n\nArguments\n\nbox::Box: a Bravais lattice\nfilename::AbstractString: filename of the .vtk file output (absolute path)\nframework::Framework: A framework containing the crystal structure information\ncenter_at_origin::Bool: center box at origin if true. if false, the origin is the corner of the box.\n\n\n\n\n\n","category":"function"},{"location":"pytools/#XtalsPyTools.jl","page":"XtalsPyTools","title":"XtalsPyTools.jl","text":"","category":"section"},{"location":"pytools/","page":"XtalsPyTools","title":"XtalsPyTools","text":"Xtals is a pure-Julia package, but we have also written some high-level tools with it that depend on Python packages. These additional methods are found in XtalsPyTools.jl.","category":"page"},{"location":"pytools/","page":"XtalsPyTools","title":"XtalsPyTools","text":"Long-term, we would like refactor these tools to depend only on Julia packages, and fold them back in to Xtals.jl. Please open an issue or make a pull request if you know how this can be done at present!","category":"page"},{"location":"pytools/#Installation","page":"XtalsPyTools","title":"Installation","text":"","category":"section"},{"location":"pytools/","page":"XtalsPyTools","title":"XtalsPyTools","text":"To gain access to these tools, add the package in the REPL package manager:","category":"page"},{"location":"pytools/","page":"XtalsPyTools","title":"XtalsPyTools","text":"pkg> add XtalsPyTools","category":"page"},{"location":"pytools/","page":"XtalsPyTools","title":"XtalsPyTools","text":"The methods in this package require scipy and/or pymatgen to be installed. To configure these dependencies automatically in a Julia-managed environment, use the quick_setup.jl script:","category":"page"},{"location":"pytools/","page":"XtalsPyTools","title":"XtalsPyTools","text":"julia quick_setup.jl","category":"page"},{"location":"pytools/#Advanced-Bond-Inference","page":"XtalsPyTools","title":"Advanced Bond Inference","text":"","category":"section"},{"location":"pytools/","page":"XtalsPyTools","title":"XtalsPyTools","text":"In addition to the infer_bonds! function, there is the infer_geometry_based_bonds! function, which uses scipy to compute the Voronoi tesselation of the atoms in a crystal. Bonds will then only be inferred between atoms which occupy neighboring Voronoi cells.","category":"page"},{"location":"pytools/#Finding-the-Primitive-Unit-Cell","page":"XtalsPyTools","title":"Finding the Primitive Unit Cell","text":"","category":"section"},{"location":"pytools/","page":"XtalsPyTools","title":"XtalsPyTools","text":"Many crystal structures found in databases are not the minimal representation, a.k.a. primitive unit cell. The primitive cell can be obtained easily by calling primitive_cell. This function requires the pymatgen python dependency.","category":"page"},{"location":"pytools/","page":"XtalsPyTools","title":"XtalsPyTools","text":"infer_geometry_based_bonds!\nprimitive_cell","category":"page"},{"location":"pytools/#XtalsPyTools.infer_geometry_based_bonds!","page":"XtalsPyTools","title":"XtalsPyTools.infer_geometry_based_bonds!","text":"infer_geometry_based_bonds!(crystal, include_bonds_across_periodic_boundaries::Bool)\n\nInfers bonds by first finding which atoms share a Voronoi face, and then bond the atoms if the distance  between them is less than the sum of the covalent radius of the two atoms (plus a tolerance).\n\nArguments\n\ncrystal::Crystal: The crystal structure\ninclude_bonds_across_periodic_boundaries::Bool: Whether to check across the periodic boundaries\nr::Float: voronoi radius, Å\npad::Float: amount to pad covalent radii, Å\ncovalent_radii::Dict{Symbol,Float64}: See covalent_radii\n\n\n\n\n\n","category":"function"},{"location":"pytools/#XtalsPyTools.primitive_cell","page":"XtalsPyTools","title":"XtalsPyTools.primitive_cell","text":"```prim = primitive_cell(xtal)```\n\nReturns the minimal representation (primitive unit cell) of a crystal structure.\n\n\n\n\n\n","category":"function"},{"location":"visualization/#Visualizing-Structures","page":"visualization","title":"Visualizing Structures","text":"","category":"section"},{"location":"visualization/","page":"visualization","title":"visualization","text":"Crystals can be visualized using Bio3DView and either Blink, Jupyter, or Pluto.","category":"page"},{"location":"visualization/","page":"visualization","title":"visualization","text":"To include a visualization within a Pluto or Jupyter notebook, simply call view_crystal.  To launch a visualization window directly from a script or the REPL, use Blink, like so:","category":"page"},{"location":"visualization/","page":"visualization","title":"visualization","text":"using Blink\nxtal = Crystal(\"SBMOF-1.cif\")\ninfer_bonds!(xtal, true)\nview_crystal(xtal)","category":"page"},{"location":"visualization/#Detailed-Docs","page":"visualization","title":"Detailed Docs","text":"","category":"section"},{"location":"visualization/","page":"visualization","title":"visualization","text":"view_crystal","category":"page"},{"location":"visualization/#Xtals.view_crystal","page":"visualization","title":"Xtals.view_crystal","text":"`view_crystal(xtal, drop_cross_pb_bonds=true)`\n\nLaunch a GUI window displaying the crystal.\n\nArguments\n\nxtal::Crystal : the crystal to display\ndrop_cross_pb_bonds::Bool : Optional. Set to true to remove bonds that extend across periodic boundaries of the unit cell (these tend to mess up the visualization). Defaults to true.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Xtals","title":"Xtals","text":"(Image: Xtals.jl)","category":"page"},{"location":"","page":"Xtals","title":"Xtals","text":"A pure-Julia package for representation of porous crystals such as metal-organic frameworks (MOFs).","category":"page"},{"location":"","page":"Xtals","title":"Xtals","text":"In development, please contribute, post issues 🐛, and improve!","category":"page"},{"location":"#Installation","page":"Xtals","title":"Installation","text":"","category":"section"},{"location":"","page":"Xtals","title":"Xtals","text":"Download and install the Julia programming language, v1.3 or higher.\nOpen the package manager in the Julia REPL (using ]) and enter:","category":"page"},{"location":"","page":"Xtals","title":"Xtals","text":"pkg> add Xtals","category":"page"},{"location":"","page":"Xtals","title":"Xtals","text":"In Julia, load all functions in Xtals.jl into the namespace:","category":"page"},{"location":"","page":"Xtals","title":"Xtals","text":"julia> using Xtals # that's it","category":"page"},{"location":"#Dependencies","page":"Xtals","title":"Dependencies","text":"","category":"section"},{"location":"","page":"Xtals","title":"Xtals","text":"Some (non-core) features of Xtals.jl require Python libraries.   If these are missing, you may see warnings when the module loads.   For users unfamiliar with configuring Python, the quick-setup script will install and build Xtals.jl along with a Python environment and the dependencies.   Run it like so:","category":"page"},{"location":"","page":"Xtals","title":"Xtals","text":"$ julia quick_setup.jl","category":"page"},{"location":"#Tests","page":"Xtals","title":"Tests","text":"","category":"section"},{"location":"","page":"Xtals","title":"Xtals","text":"Unit tests for the package are available by doing ] test Xtals in the Julia REPL.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"DocTestSetup = quote\n  using Xtals\nend","category":"page"},{"location":"crystal/#Crystals","page":"crystals","title":"Crystals","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"Xtals.jl maintains a data structure Crystal that stores information about a crystal structure file.","category":"page"},{"location":"crystal/#Reading-in-a-Crystal-Structure-File","page":"crystals","title":"Reading in a Crystal Structure File","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"Currently, the crystal structure file reader accepts .cif and .cssr file formats.  Xtals.jl looks for the crystal structure files in rc[:paths][:crystals] which is by default ./data/crystals (relative to pwd() at module loading).  By typing rc[:paths][:crystals] = \"my_crystal_dir\", Xtals.jl now looks for the crystal structure file in my_crystal_dir. The files can be read as:","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"xtal = Crystal(\"IRMOF-1.cif\")       # The crystal reader stores the information in xtal\nxtal.name                           # The name of the crystal structure file\nxtal.box                            # The unit cell information\nxtal.atoms                          # The atom coordinates (in fractional space) and the atom identities\nxtal.charges                        # The charge magnitude and coordinates (in fractional space)\nxtal.bonds                          # Bonding information in the structure. By default this is an empty graph,\n                                    #  but use `read_bonds_from_file=true` argument in `Crystal` to read from crystal structure file\nxtal.symmetry                       # Symmetry information of the crystal. By default converts the symmetry to P1 symmetry.\n                                    #  Use `convert_to_p1=false` argument in `Crystal` to keep original symmetry","category":"page"},{"location":"crystal/#Fixing-Atom-Species-Labels","page":"crystals","title":"Fixing Atom Species Labels","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"Often, the atoms species are appended by numbers.  This messes with the internal workings of Xtals.jl. To circumvent this problem, the function strip_numbers_from_atom_labels! removes the appended numbers. It is important to use this function prior to GCMC or Henry coefficient calculations and bond inference operations.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"xtal = Crystal(\"IRMOF-1.cif\", species_col=[\"_atom_site_label\"])\nxtal.atoms.species[1]\n# output\n:Zn1","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"strip_numbers_from_atom_labels!(xtal)\nxtal.atoms.species[1]\n# output\n:Zn","category":"page"},{"location":"crystal/#Converting-the-Coordinates-to-Cartesian-Space","page":"crystals","title":"Converting the Coordinates to Cartesian Space","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"The coordinates of the Crystal's Atoms are stored in Fractional coordinates.  If one needs to analyze the Cartesian coordinates of the Crystal, that can be done by using the unit cell (Box) information.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"xtal.atoms.coords.xf                                    # array of fractional coordinates\ncart_coords = xtal.box.f_to_c * xtal.atoms.coords.xf    # array of cartesian coordinates","category":"page"},{"location":"crystal/#Creating-a-Super-Cell","page":"crystals","title":"Creating a Super-Cell","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"For many simulations, one needs to replicate the unit cell multiple times to create a bigger super-cell. This is done with replicate:","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"super_xtal = replicate(xtal, (2,2,2))       # Replicates the original unit cell once in each dimension\nxtal.atoms.n, super_xtal.atoms.n\n# output\n(424, 3392)","category":"page"},{"location":"crystal/#Finding-Other-Properties","page":"crystals","title":"Finding Other Properties","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"rho = crystal_density(xtal)         # Crystal density of the crystal in kg/m^2\nmw = molecular_weight(xtal)         # The molecular weight of the unit cell in amu\nformula = empirical_formula(xtal)   # The irreducible chemical formula of the crystal","category":"page"},{"location":"crystal/#Assigning-New-Charges","page":"crystals","title":"Assigning New Charges","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"If the structure file does not contain partial charges, we provide methods to assign new Charges to the Crystal.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"species_to_charge = Dict(:Zn => 2.0, :C => 0.0, :H => 0.0, :O => -0.61538)  # This method assigns a static charge to atom species\ncharged_xtal = assign_charges(xtal, species_to_charge, 1e-3)                # This function creates a new charged `Crystal` object.\n                                                                            #   The function checks for charge neutrality with a tolerance of 1e-3\nnew_charges = Charges(zeros(xtal.atoms.n), xtal.atoms.coords)\nother_charged_xtal = Crystal(xtal.name, xtal.box, xtal.atoms,               # Here we create a new `Charges` object using an array of new charges.\n                             new_charges, xtal.bonds, xtal.symmetry)        #   The number of charges in the array has to be equal to the number of atoms\n                                                                            #   and finally a new `Crystal` object is manually created","category":"page"},{"location":"crystal/#Writing-Crystal-Files","page":"crystals","title":"Writing Crystal Files","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"We provide methods to write both .xyz and .cif files.","category":"page"},{"location":"crystal/","page":"crystals","title":"crystals","text":"write_cif(xtal, \"my_new_cif_file.cif\")      # Stored in the current directory\nwrite_xyz(xtal, \"my_new_xyz_file.xyz\")      # stored in the current directory","category":"page"},{"location":"crystal/#Detailed-Docs","page":"crystals","title":"Detailed Docs","text":"","category":"section"},{"location":"crystal/","page":"crystals","title":"crystals","text":"    Crystal\n    Xtals.SymmetryInfo\n    strip_numbers_from_atom_labels!\n    replicate\n    molecular_weight\n    crystal_density\n    empirical_formula\n    assign_charges\n    write_cif\n    write_xyz\n    read_xyz\n    read_mol","category":"page"},{"location":"crystal/#Xtals.Crystal","page":"crystals","title":"Xtals.Crystal","text":"crystal = Crystal(filename;\n    check_neutrality=true, net_charge_tol=1e-4,\n    check_overlap=true, convert_to_p1=true, \n    read_bonds_from_file=false, wrap_coords=true,\n    include_zero_charges=true,\n    remove_duplicates=false,\n    species_col=[\"_atom_site_type_symbol\", \"_atom_site_label\"]\n    ) # read from file\n\ncrystal = Crystal(name, box, atoms, charges) # construct from matter, no bonds, P1-symmetry assumed\n\nRead a crystal structure file (.cif or .cssr) and populate a Crystal data structure, or construct a Crystal data structure directly.\n\nArguments\n\nfilename::String: the name of the crystal structure file (include \".cif\" or \".cssr\") read from PATH_TO_CRYSTALS.\ncheck_neutrality::Bool: check for charge neutrality\nnet_charge_tol::Float64: when checking for charge neutrality, throw an error if the absolute value of the net charge is larger than this value.\ncheck_overlap::Bool: throw an error if overlapping atoms are detected.\nconvert_to_p1::Bool: If the structure is not in P1 it will be converted to   P1 symmetry using the symmetry rules from the _symmetry_equiv_pos_as_xyz list in the .cif file.   (We do not use the space groups name to look up symmetry rules).\nread_bonds_from_file::Bool: Whether or not to read bonding information from   cif file. If false, the bonds can be inferred later. note that, if the crystal is not in P1 symmetry, we cannot both read bonds and convert to P1 symmetry.\nwrap_coords::Bool: if true, enforce that fractional coords of atoms and charges are in [0,1]³ by mod(x, 1)\ninclude_zero_charges::Bool: if false, do not include in crystal.charges atoms which have zero charges, in order to speed up the electrostatic calculations.   If true, include the atoms in crystal.charges that have zero charge, ensuring that the number of atoms is equal to the number of charges and that crystal.charges.coords.xf and crystal.atoms.coords.xf are the same.\nremove_duplicates::Bool: remove duplicate atoms and charges. an atom is duplicate only if it is the same species.\nspecies_col::Array{String}: which column to use for species identification for crystal.atoms.species. we use a priority list:   we check for the first entry of species_col in the .cif file; if not present, we then use the second entry, and so on.\ninfer_bonds::Bool: if true, bonds are inferred automatically. If set, must specify periodic_boundaries. By default, bonds are not inferred.\nperiodic_boundaries::Union{Bool, Missing}: use with infer_bonds to specify treatment of the unit cell boundary.  Set true to treat the unit cell edge as a periodic boundary (allow bonds across it); set false to restrict bonding to within the local unit cell. By default, no bonds are inferred.\nabsolute_path::Bool: set true to load from an absolute path instead of the default path stored in rc[:paths][:crystals].\n\nReturns\n\ncrystal::Crystal: A crystal containing the crystal structure information\n\nAttributes\n\nname::AbstractString: name of crystal structure\nbox::Box: unit cell (Bravais Lattice)\natoms::Atoms: list of Atoms in crystal unit cell\ncharges::Charges: list of point charges in crystal unit cell\nbonds::MetaGraph: Unweighted, undirected graph showing all of the atoms   that are bonded within the crystal\nsymmetry::SymmetryInfo: symmetry inforomation\n\n\n\n\n\n","category":"type"},{"location":"crystal/#Xtals.SymmetryInfo","page":"crystals","title":"Xtals.SymmetryInfo","text":"SymmetryInfo(symmetry, space_group, is_p1)\n\nAttributes\n\noperations::Array{Function, 2}: 2D array of anonymous functions that represent   the symmetry operations. If the structure is in P1 there will be one   symmetry operation.\nspace_group::AbstractString: The name of the space group. This is stored   so that it can be written out again in the write_cif function. The space   group is not used to verify the symmetry rules.\nis_p1::Bool: Stores whether the crystal is currently in P1 symmetry.\n\n\n\n\n\n","category":"type"},{"location":"crystal/#Xtals.strip_numbers_from_atom_labels!","page":"crystals","title":"Xtals.strip_numbers_from_atom_labels!","text":"strip_numbers_from_atom_labels!(crystal)\n\nStrip numbers from labels for crystal.atoms. Precisely, for atom in crystal.atoms, find the first number that appears in atom. Remove this number and all following characters from atom. e.g. C12 –> C      Ba12A_3 –> Ba\n\nArguments\n\ncrystal::Crystal: The crystal containing the crystal structure information\n\n\n\n\n\n","category":"function"},{"location":"crystal/#Xtals.replicate","page":"crystals","title":"Xtals.replicate","text":"new_box = replicate(original_box, repfactors)\n\nReplicates a Box in positive directions to construct a new Box representing a supercell. The original_box is replicated according to the factors in repfactors. Note replicate(original_box, repfactors=(1, 1, 1)) returns same Box. The new fractional coordinates as described by f_to_c and c_to_f still ∈ [0, 1].\n\nArguments\n\noriginal_box::Box: The box that you want to replicate\nrepfactors::Tuple{Int, Int, Int}: The factor you want to replicate the box by\n\nReturns\n\nbox::Box: Fully formed Box object\n\n\n\n\n\nreplicated_crystal = replicate(crystal, repfactors)\n\nreplicate the atoms and charges in a Crystal in positive directions to construct a new Crystal. Note replicate(crystal, (1, 1, 1)) returns the same Crystal. the fractional coordinates will be rescaled to be in [0, 1].\n\narguments\n\ncrystal::Crystal: The crystal to replicate\nrepfactors::Tuple{Int, Int, Int}: The factors by which to replicate the crystal structure in each crystallographic direction (a, b, c).\n\nreturns\n\nreplicated_frame::Crystal: replicated crystal\n\n\n\n\n\n","category":"function"},{"location":"crystal/#Xtals.molecular_weight","page":"crystals","title":"Xtals.molecular_weight","text":"mass_of_crystal = molecular_weight(crystal)\n\nCalculates the molecular weight of a unit cell of the crystal in amu using information stored in data/atomicmasses.csv.\n\nArguments\n\ncrystal::Crystal: The crystal containing the crystal structure information\n\nReturns\n\nmass_of_crystal::Float64: The molecular weight of a unit cell of the crystal in amu\n\n\n\n\n\n","category":"function"},{"location":"crystal/#Xtals.crystal_density","page":"crystals","title":"Xtals.crystal_density","text":"ρ = crystal_density(crystal) # kg/m²\n\nCompute the crystal density of a crystal. Pulls atomic masses from read_atomic_masses.\n\nArguments\n\ncrystal::Crystal: The crystal containing the crystal structure information\n\nReturns\n\nρ::Float64: The crystal density of a crystal in kg/m³\n\n\n\n\n\n","category":"function"},{"location":"crystal/#Xtals.empirical_formula","page":"crystals","title":"Xtals.empirical_formula","text":"formula = empirical_formula(crystal, verbose=false)\n\nFind the irreducible chemical formula of a crystal structure.\n\nArguments\n\ncrystal::Crystal: The crystal containing the crystal structure information\nverbose::Bool: If true, will print the chemical formula as well\n\nReturns\n\nformula::Dict{Symbol, Int}: A dictionary with the irreducible chemical formula of a crystal structure\n\n\n\n\n\n","category":"function"},{"location":"crystal/#Xtals.assign_charges","page":"crystals","title":"Xtals.assign_charges","text":"crystal_with_charges = assign_charges(crystal, species_to_charge, net_charge_tol=1e-5)\n\nassign charges to the atoms present in the crystal based on atom type. pass a dictionary species_to_charge that maps atomic species to a charge.\n\nif the crystal already has charges, the charges are removed and new charges are added. a warning is thrown if this is the case.\n\nchecks for charge neutrality in the end.\n\nreturns a new crystal.\n\nExamples\n\nspecies_to_charge = Dict(:Ca => 2.0, :C => 1.0, :H => -1.0)\ncrystal_with_charges = assign_charges(crystal, species_to_charge, 1e-7)\ncrystal_with_charges = assign_charges(crystal, species_to_charge) # tol 1e-5 default\n\nArguments\n\ncrystal::Crystal: the crystal\nspecies_to_charge::Dict{Symbol, Float64}: a dictionary that maps atomic species to charge\nnet_charge_tol::Float64: the net charge tolerated when asserting charge neutrality of\n\nthe resulting crystal\n\n\n\n\n\n","category":"function"},{"location":"crystal/#Xtals.write_cif","page":"crystals","title":"Xtals.write_cif","text":"write_cif(crystal, filename; fractional_coords=true, number_atoms=true)\nwrite_cif(crystal) # writes to file crystal.name\n\nWrite a crystal::Crystal to a .cif file.\n\narguments\n\ncrystal::Crystal: crystal to write to file\nfilename::String: the filename of the .cif file. if \".cif\" is not included as an extension, it will automatically be appended to the filename string.\nfractional_coords::Bool=true: write the coordinates of the atoms as fractional coords if true. if false, write Cartesian coords.\nnumber_atoms::Bool=true: write the atoms as \"C1\", \"C2\", \"C3\", ..., \"N1\", \"N2\", ... etc. to give each atom a unique identifier\n\n\n\n\n\n","category":"function"},{"location":"crystal/#Xtals.write_xyz","page":"crystals","title":"Xtals.write_xyz","text":"write_xyz(atoms, filename; comment=\"\")\nwrite_xyz(crystal; comment=\"\", center_at_origin=false)\nwrite_xyz(molecules, box, filename; comment=\"\") # fractional\nwrite_xyz(molecules, box, filename; comment=\"\") # Cartesian\n\nwrite atoms to an .xyz file.\n\nArguments\n\natoms::Atoms: the set of atoms.\nfilename::AbstractString: the filename (absolute path) of the .xyz file. (\".xyz\" appended automatically\n\nif the extension is not provided.)\n\ncomment::AbstractString: comment if you'd like to write to the file.\ncenter_at_origin::Bool: (for crystal only) if true, translate all coords such that the origin is the center of the unit cell.\n\n\n\n\n\n","category":"function"},{"location":"crystal/#Xtals.read_xyz","page":"crystals","title":"Xtals.read_xyz","text":"atoms = read_xyz(\"molecule.xyz\")\n\nread a list of atomic species and their corresponding coordinates from an .xyz file.\n\nArguments\n\nfilename::AbstractString: the path to and filename of the .xyz file\n\nReturns\n\natoms::Atoms{Cart}: the set of atoms read from the .xyz file.\n\n\n\n\n\n","category":"function"},{"location":"crystal/#Xtals.read_mol","page":"crystals","title":"Xtals.read_mol","text":"atoms, bonds = read_mol(\"molecule.mol\")\n\nread a .mol file, which contains info about both atoms and bonds. see here for the anatomy of a .mol file.\n\nArguments\n\nfilename::AbstractString: the path to and filename of the .mol file (must pass extension)\n\nReturns\n\natoms::Atoms{Cart}: the set of atoms read from the .mol file.\nbonds::MetaGraph: the bonding graph of the atoms read from the .mol file.\nbond_types::Array{Int, 1}: the array of bond types.\n\n\n\n\n\n","category":"function"}]
}
